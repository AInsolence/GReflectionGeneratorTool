#include "CodeGenerator.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <filesystem>

namespace ReflectionGenerator {

CodeGenerator::CodeGenerator(const std::string& outputDir)
    : m_outputDir(outputDir) {
    EnsureDirectoryExists(m_outputDir);
}

void CodeGenerator::GenerateCode(const std::string& filePath, const std::vector<ClassInfo>& classes) {
    if (classes.empty()) {
        return;
    }
    
    // Generate code for each class
    for (const auto& classInfo : classes) {
        std::string headerPath = GetOutputPath(filePath, classInfo.name + ".generated.h");
        std::string implPath = GetOutputPath(filePath, classInfo.name + ".generated.cpp");
        
        GenerateHeader(classInfo, headerPath);
        GenerateImplementation(classInfo, implPath);
    }
    
    // Generate registration file if there are multiple classes
    if (classes.size() > 1) {
        std::string regPath = GetOutputPath(filePath, "Registration.generated.cpp");
        GenerateRegistration(classes, regPath);
    }
}

void CodeGenerator::GenerateHeader(const ClassInfo& classInfo, const std::string& outputPath) {
    EnsureDirectoryExists(std::filesystem::path(outputPath).parent_path().string());
    
    std::ofstream file(outputPath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << outputPath << "\n";
        return;
    }
    
    WriteHeaderPreamble(file, classInfo);
    WriteHeaderIncludes(file, classInfo);
    WriteHeaderClass(file, classInfo);
    WriteHeaderEpilogue(file, classInfo);
    
    file.close();
}

void CodeGenerator::GenerateImplementation(const ClassInfo& classInfo, const std::string& outputPath) {
    EnsureDirectoryExists(std::filesystem::path(outputPath).parent_path().string());
    
    std::ofstream file(outputPath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << outputPath << "\n";
        return;
    }
    
    WriteImplementationPreamble(file, classInfo);
    WriteImplementationIncludes(file, classInfo);
    WriteImplementationClass(file, classInfo);
    WriteImplementationEpilogue(file, classInfo);
    
    file.close();
}

void CodeGenerator::GenerateRegistration(const std::vector<ClassInfo>& classes, const std::string& outputPath) {
    EnsureDirectoryExists(std::filesystem::path(outputPath).parent_path().string());
    
    std::ofstream file(outputPath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << outputPath << "\n";
        return;
    }
    
    file << "// Generated registration code\n";
    file << "// This file is automatically generated by the reflection generator\n\n";
    
    file << "#include \"Core/TypeRegistry.h\"\n";
    file << "#include \"Core/GObject.h\"\n\n";
    
    // Include all generated headers
    for (const auto& classInfo : classes) {
        file << "#include \"" << classInfo.name << ".generated.h\"\n";
    }
    
    file << "\nnamespace Engine {\n";
    file << "namespace Core {\n\n";
    
    file << "void RegisterReflectionTypes() {\n";
    
    for (const auto& classInfo : classes) {
        file << "    // Register " << classInfo.name << "\n";
        file << "    " << classInfo.name << "::RegisterType();\n";
    }
    
    file << "}\n\n";
    file << "} // namespace Core\n";
    file << "} // namespace Engine\n";
    
    file.close();
}

std::string CodeGenerator::GetOutputPath(const std::string& filePath, const std::string& suffix) {
    std::filesystem::path sourcePath(filePath);
    std::string fileName = sourcePath.stem().string();
    std::string extension = sourcePath.extension().string();
    
    // Create output directory structure
    std::string outputPath = m_outputDir + "/" + fileName + "_" + suffix;
    
    return outputPath;
}

std::string CodeGenerator::GetIncludeGuard(const std::string& className) {
    std::string guard = "ENGINE_" + className + "_GENERATED_H";
    std::transform(guard.begin(), guard.end(), guard.begin(), ::toupper);
    return guard;
}

std::string CodeGenerator::GetNamespacePrefix(const std::string& namespaceName) {
    if (namespaceName.empty()) {
        return "";
    }
    return "namespace " + namespaceName + " {\n";
}

std::string CodeGenerator::GetNamespaceSuffix(const std::string& namespaceName) {
    if (namespaceName.empty()) {
        return "";
    }
    return "} // namespace " + namespaceName + "\n";
}

void CodeGenerator::WriteHeaderPreamble(std::ofstream& file, const ClassInfo& classInfo) {
    std::string guard = GetIncludeGuard(classInfo.name);
    
    file << "#ifndef " << guard << "\n";
    file << "#define " << guard << "\n\n";
    
    file << "// Generated reflection code for class " << classInfo.name << "\n";
    file << "// This file is automatically generated by the reflection generator\n";
    file << "// Do not edit this file manually\n\n";
}

void CodeGenerator::WriteHeaderIncludes(std::ofstream& file, const ClassInfo& classInfo) {
    file << "#include \"Core/GObject.h\"\n";
    file << "#include \"Core/TypeRegistry.h\"\n";
    file << "#include \"Core/BinarySerializer.h\"\n";
    file << "#include <string>\n";
    file << "#include <memory>\n\n";
}

void CodeGenerator::WriteHeaderClass(std::ofstream& file, const ClassInfo& classInfo) {
    file << GetNamespacePrefix(classInfo.namespaceName);
    
    file << "class " << classInfo.name << ";\n\n";
    
    // Forward declarations for generated functions
    file << "// Generated reflection functions\n";
    file << "void Register" << classInfo.name << "Type();\n";
    file << "std::unique_ptr<" << classInfo.name << "> Create" << classInfo.name << "Instance();\n\n";
    
    file << GetNamespaceSuffix(classInfo.namespaceName);
}

void CodeGenerator::WriteHeaderEpilogue(std::ofstream& file, const ClassInfo& classInfo) {
    file << "\n#endif // " << GetIncludeGuard(classInfo.name) << "\n";
}

void CodeGenerator::WriteImplementationPreamble(std::ofstream& file, const ClassInfo& classInfo) {
    file << "// Generated reflection implementation for class " << classInfo.name << "\n";
    file << "// This file is automatically generated by the reflection generator\n";
    file << "// Do not edit this file manually\n\n";
}

void CodeGenerator::WriteImplementationIncludes(std::ofstream& file, const ClassInfo& classInfo) {
    file << "#include \"" << classInfo.name << ".generated.h\"\n";
    file << "#include \"Core/GObject.h\"\n";
    file << "#include \"Core/TypeRegistry.h\"\n";
    file << "#include \"Core/BinarySerializer.h\"\n";
    file << "#include <typeinfo>\n\n";
}

void CodeGenerator::WriteImplementationClass(std::ofstream& file, const ClassInfo& classInfo) {
    file << GetNamespacePrefix(classInfo.namespaceName);
    
    // Write type registration function
    file << "void Register" << classInfo.name << "Type() {\n";
    file << "    auto type = std::make_unique<GType>(\n";
    file << "        \"" << classInfo.name << "\",\n";
    file << "        typeid(" << classInfo.name << "),\n";
    file << "        sizeof(" << classInfo.name << ")\n";
    file << "    );\n\n";
    
    // Register properties
    for (const auto& property : classInfo.properties) {
        WritePropertyRegistration(file, property);
    }
    
    // Register functions
    for (const auto& function : classInfo.functions) {
        WriteFunctionRegistration(file, function);
    }
    
    file << "    TypeRegistry::GetInstance().RegisterType(std::move(type));\n";
    file << "}\n\n";
    
    // Write factory function
    file << "std::unique_ptr<" << classInfo.name << "> Create" << classInfo.name << "Instance() {\n";
    file << "    return std::make_unique<" << classInfo.name << ">();\n";
    file << "}\n\n";
    
    // Write serialization code
    WriteSerializationCode(file, classInfo);
    WriteDeserializationCode(file, classInfo);
    
    file << GetNamespaceSuffix(classInfo.namespaceName);
}

void CodeGenerator::WriteImplementationEpilogue(std::ofstream& file, const ClassInfo& classInfo) {
    // Static registration
    file << "\n// Static registration\n";
    file << "static struct " << classInfo.name << "Registration {\n";
    file << "    " << classInfo.name << "Registration() {\n";
    file << "        Register" << classInfo.name << "Type();\n";
    file << "    }\n";
    file << "} g_" << classInfo.name << "Registration;\n";
}

void CodeGenerator::WritePropertyRegistration(std::ofstream& file, const PropertyInfo& property) {
    file << "    // Property: " << property.name << "\n";
    file << "    auto " << property.name << "Property = std::make_unique<GProperty>(\n";
    file << "        \"" << property.name << "\",\n";
    file << "        nullptr, // Type will be set by generator\n";
    file << "        offsetof(" << property.type << ", " << property.name << "),\n";
    file << "        " << GetPropertyFlagsString(property) << "\n";
    file << "    );\n";
    file << "    type->AddProperty(std::move(" << property.name << "Property));\n\n";
}

void CodeGenerator::WriteFunctionRegistration(std::ofstream& file, const FunctionInfo& function) {
    file << "    // Function: " << function.name << "\n";
    file << "    auto " << function.name << "Function = std::make_unique<GFunction>(\n";
    file << "        \"" << function.name << "\",\n";
    file << "        nullptr, // Function pointer will be set by generator\n";
    file << "        " << GetFunctionFlagsString(function) << "\n";
    file << "    );\n";
    file << "    type->AddFunction(std::move(" << function.name << "Function));\n\n";
}

void CodeGenerator::WriteSerializationCode(std::ofstream& file, const ClassInfo& classInfo) {
    file << "// Serialization implementation for " << classInfo.name << "\n";
    file << "void " << classInfo.name << "::Serialize(BinarySerializer& serializer) const {\n";
    file << "    // Call base class serialization\n";
    if (!classInfo.baseClass.empty()) {
        file << "    " << classInfo.baseClass << "::Serialize(serializer);\n";
    }
    file << "    \n";
    file << "    // Serialize properties\n";
    
    for (const auto& property : classInfo.properties) {
        if (property.save && !property.transient) {
            file << "    if (auto* prop = GetType()->GetProperty(\"" << property.name << "\")) {\n";
            file << "        void* propPtr = prop->GetPropertyPtr(const_cast<" << classInfo.name << "*>(this));\n";
            file << "        // Serialize property based on type\n";
            file << "        // This will be expanded by the generator based on property type\n";
            file << "    }\n";
        }
    }
    
    file << "}\n\n";
}

void CodeGenerator::WriteDeserializationCode(std::ofstream& file, const ClassInfo& classInfo) {
    file << "// Deserialization implementation for " << classInfo.name << "\n";
    file << "void " << classInfo.name << "::Deserialize(BinaryDeserializer& deserializer) {\n";
    file << "    // Call base class deserialization\n";
    if (!classInfo.baseClass.empty()) {
        file << "    " << classInfo.baseClass << "::Deserialize(deserializer);\n";
    }
    file << "    \n";
    file << "    // Deserialize properties\n";
    
    for (const auto& property : classInfo.properties) {
        if (property.save && !property.transient) {
            file << "    if (auto* prop = GetType()->GetProperty(\"" << property.name << "\")) {\n";
            file << "        void* propPtr = prop->GetPropertyPtr(this);\n";
            file << "        // Deserialize property based on type\n";
            file << "        // This will be expanded by the generator based on property type\n";
            file << "    }\n";
        }
    }
    
    file << "}\n\n";
}

std::string CodeGenerator::GetPropertyFlagsString(const PropertyInfo& property) {
    std::stringstream flags;
    flags << "GProperty::Flags::";
    
    bool first = true;
    if (property.save) {
        if (!first) flags << " | ";
        flags << "Save";
        first = false;
    }
    if (property.edit) {
        if (!first) flags << " | ";
        flags << "Edit";
        first = false;
    }
    if (property.transient) {
        if (!first) flags << " | ";
        flags << "Transient";
        first = false;
    }
    if (property.editorOnly) {
        if (!first) flags << " | ";
        flags << "EditorOnly";
        first = false;
    }
    if (property.readOnly) {
        if (!first) flags << " | ";
        flags << "ReadOnly";
        first = false;
    }
    
    if (first) {
        flags << "None";
    }
    
    return flags.str();
}

std::string CodeGenerator::GetFunctionFlagsString(const FunctionInfo& function) {
    std::stringstream flags;
    flags << "GFunction::Flags::";
    
    bool first = true;
    if (function.callable) {
        if (!first) flags << " | ";
        flags << "Callable";
        first = false;
    }
    if (function.blueprintEvent) {
        if (!first) flags << " | ";
        flags << "BlueprintEvent";
        first = false;
    }
    if (function.blueprintCallable) {
        if (!first) flags << " | ";
        flags << "BlueprintCallable";
        first = false;
    }
    
    if (first) {
        flags << "None";
    }
    
    return flags.str();
}

std::string CodeGenerator::GetClassFlagsString(const ClassInfo& classInfo) {
    std::stringstream flags;
    
    bool first = true;
    if (classInfo.blueprintable) {
        if (!first) flags << " | ";
        flags << "GFLAG_BLUEPRINTABLE";
        first = false;
    }
    if (classInfo.serializable) {
        if (!first) flags << " | ";
        flags << "GFLAG_SERIALIZABLE";
        first = false;
    }
    if (classInfo.abstract) {
        if (!first) flags << " | ";
        flags << "GFLAG_ABSTRACT";
        first = false;
    }
    if (classInfo.defaultToInstanced) {
        if (!first) flags << " | ";
        flags << "GFLAG_DEFAULT_TO_INSTANCED";
        first = false;
    }
    
    if (first) {
        flags << "0";
    }
    
    return flags.str();
}

std::string CodeGenerator::GetTypeRegistrationName(const std::string& typeName) {
    return "Register" + typeName + "Type";
}

std::string CodeGenerator::GetPropertyTypeName(const std::string& typeName) {
    // Convert C++ type names to reflection type names
    if (typeName == "int") return "int32_t";
    if (typeName == "float") return "float";
    if (typeName == "double") return "double";
    if (typeName == "bool") return "bool";
    if (typeName == "std::string") return "std::string";
    if (typeName.find("glm::vec") == 0) return typeName;
    if (typeName.find("glm::mat") == 0) return typeName;
    
    return typeName;
}

void CodeGenerator::EnsureDirectoryExists(const std::string& path) {
    if (!path.empty()) {
        std::filesystem::create_directories(path);
    }
}

std::string CodeGenerator::GetRelativePath(const std::string& from, const std::string& to) {
    std::filesystem::path fromPath(from);
    std::filesystem::path toPath(to);
    
    return std::filesystem::relative(toPath, fromPath.parent_path()).string();
}

} // namespace ReflectionGenerator

